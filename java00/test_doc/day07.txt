#day07

배열의 정렬
	
	치환정렬을 해서 정렬한다.
	이 때 방법은
	처음부터 하나씩 꺼내고 
	비교를 하는데 대상은 꺼낸 다음데이터부터 끝까지 꺼내서 비교를 해서
	오름차순이라면 
		대상이 더 작다면 현재 데이터와 교체를 해줘야 한다.
		
	이때 주의사항은
	현재데이터에 데이터를 입력하는 순간
	기존데이터는 사자질 것이고 찾을 방법이 없다
	따라서 사라지기 전에 어딘가에 저장을 해둬야 한다.
	
	------------------------------------------------------------------------------
#flag 기법 

	==> 프로그램을 실해아다보면
		두가지 이상의 경우가 발생이 되서 처리된 것인지 알아보는 기법
		
		예]
			for(){
				break; // 이 명령이 실행이 되면 (1)이 실행이 된다.
				(0)
			}
			(1)
			==> 부분은 for명령이 정상적으로 종료된 후에 실행되는 부분이다.
			
			
			문제] 
				(1) 부분은 실행할 때 정상적으로 종료되었는지? 
				break; 만나서 종료되었는지 
				알수없다.
				
				
			방법]
				시작하기전에 변수에 특정 데이터로 초기화를 시켜놓고 
				특정 순간이 발생되면 변수의 데이터를 변경시킨다.
				(break 되?? 바로 전에...)
				
				(1) 번 부분에서는 변수의 값에 따라서 반복문이 정상적으로 모두 실행이 되었는지
				아니면 중간에 중단이 되었는지 판단 할수 있게 된다.

--------------------------------------------------------------------------------------------------------

배열의 복사
	
	1. 얕은 복사 
		==> 주소만 복사 해주는 기법 
		
			특징 ] 
				데이터는 공유하므로 한 곳에서 수정하면 
				다른곳에서도 수정된 데이터를 사용하게 된다.
				
			복사 방법 ]
				
				int[] num1 = new int[5];
				......
				
				int[] num2; ---> 이것은 배열 주소를 기억할 변수를 만들어 주는 것
								 num2안에는 데이터는 기억할 수 없고 
								 오직 주소만 기억할수 있다.
				num2 = num1;	==> 얕은 복사
				
			참고 ] 
				얕은 복사는 
				지역변수는 그 지역에서만 활동 하므로 
				다른 지역에서 Heap 영역의 데이터를 사용할 목적으로 많이 사용되는 기법
				
				다른 지역에서 만든 Heap 영역의 데이터를 
				다른 지역에서도 같이 사용할 목적으로 많이 사용되는 기법
				
	2. 깊은 복사 
		==> 데이터까지 모두 복사해주는 기법
			==> 데이터가 복사되는 것은
				Heap 영역에 다른곳에 데이터가 한번더 존재한다는 의미이므로 
				데이터의 주소가 달라지게 되므로
				
			특징]
				복사된 데이터는 독립적으로 사용 된다.
				
			생성 방법]
				
				System.arraycopy(#1,#2,#3,#4,#5);
					
					#1 - 원본 데이터의 주소 
					#2 - 원본 데이터의 복사를 시작한 위치(index)
					#3 - 복사 받을 배열의 주소 
					#4 - 복사 받을 배열의 입력 시작 위치 
					#5 - 복사 받을 데이터의 갯수 
					
------------------------------------------------------------------------------------------

배열의 단점
	1. 한번 배열의 크기를 정하면 크기 조절이 불가능 하다.
		예]
			int[] num = new int[10];
			// 정수 데이터를 10개 관리할 예정이다. 
			// 이때 정수 데이터가 11개를 관리 해야 한다면 
			// 원칙적으로는 불가능 하다.
			// 이 때 해결 방법은 깊은 복사를 해줘야 한다.
			
			int[] num2 = new int[20];
			// num2 의 앞부분에 깊은 복사로 데이터를 채워 넣으면
			// 이후 10개를 더 정해서 사용 가능 하다 .
			
	2. 같은 타입의 데이터만 입력할수 있다. 
	
		==> 주소는 Heap Type 에 의해서 결정된다.
			Heap Type 다르면 사용할수 없다( 호환이 안된다.)
			
			예]
				int[] no = new int[10];
				
				float[] no2;
				no2 = no;
--------------------------------------------------------------------------

String 배열

	참고]
		String 역시 참조형 변수이다. 주소를 기억하고 있다.
		
		String str = "hong";
		이라고 정의를 하면 str 속엔 
		Heap에 만들어진 주소를 기억하고 있다.
		"hong"은 리터럴 풀에 기억된다.
		
	참고 2]
		문자열 만드는 방법1]
			String 변수이름 = "데이터";
			
		문자열 만드는 방법2]
			String 변수이름 = new String(문자열데이터);
			
			
	*****
	문자열은 변경이 자주 일어나는 문자열의 경우
	String가 아닌
	StringBuffer 나 StringBuild 타입으로 만들고 연산해서
	최종적으로 변경된 데이터를 String 타입으로 사용하는것이 좋다.
	
	참고 3]
		레퍼런스 변수란? 
			주소를 기억하는 변수
			하지만 프로그램에서는 주소는 필요하지 않다.
			오직 데이터가 필요할 뿐이다.
			따라서 주소변수는 데이터가 존재하는 위치를 알려?? 뿐..
			핵심은 데이터가 들어갈 메모리 즉 실제 데이터가 더 중요!
			
	문자열 배열 생성 방법]
		
		String[] 변수이름;
		변수이름 = new String[길이];
		==> String[] 변수이름 = new String[길이]
		
		변수이름[index] = 문자열데이타;
		
		
		문자열 배열도 초기화가 가능하다.
		
		String[] 변수이름 = {문자열1,문자열2,....};
		String[] 변수이름 =  new String[]{문자열1,문자열2,....};

문자열에서 자주 사용하는 함수		
	1. String은 필요에 따라서 문자배열로 변환해서 사용할수있다.
	
		함수[
			toCharArray() : 문자열을 문자배열로 반환해주는 함수
			
	2. charAt(위치)
		: 해당 위치의 문자를 반환해주는 함수
		
	3. indexOf(문자)
		: 문자열에서 해당문자가 위치하는 위치값을 반환 
		
	4. length()
		: 문자열의 길이를 반환해주는 함수
		
	5. substring()
		: 문자열중에서 원하는 문자열만 뽑아서 반환해주는 함수
		
		형식 1]
			substring(시작위치) 
			==> 시작위치에서 부터 맨마직까지 추출후 반환
		
		형식 2]
			substring(시작위치, 종료위치);
			==> 시작위치부터 종료위치까지 꺼내서 반환해주는 함수
			
			*
			주의]
				시작위치는 0부터 카운트를하고
				종료위치는 반환 문자열에서 제외되서 반환...
				종료위치 전 문자까지만 추출해서 반환해준다.
				
	6. equals(문자열)
		==> 문자열의 데이터가 같은 값인지 비교하는 벙법
			
			형식]
				문자열1.equals(문자열2)
				==> 반환값은 boolean 타입의 데이터로 반화.
				
				
				
--------------------------------------------------------------------------
반장님 문제]
 	45~1 까지 저장할 배열을 만들고
 	배열에서 로또 번호를 꺼내서 로또 한게임을 만들고 출력하세요 
 	
문제 1]
	알파벳 10개를 저장할 배열을 만들고 
	대문자 10개를 랜덤하게 추출해서 배열에저장 하고
	저장된 배열을 얕은 복사로 복사하고 
	출력하고,
	원래 배열을 소문자로 변경한 후 
	두 배열을 출력하세요  

문제 2]
	정수 10개를 저장 할 배열을 만들고 
	랜덤하게 정수를 1~50 까지 수중 발생시켜서
	배열에 담고 
	배열의 5번째까지 데이터를 깊은 복사로 복사 해..

문제 3] 
	회원 이름, 전화번호, 이메일 저장할 배열을 만들고 
	
	
	이름을 입력하면 
	
	그사람의 데이터를 모두 저장할 배열을 만들어서 
	데이터를 넣고 출력 하시요
	
문제 4] 
	전화번호를 입력하면 
	'-'를 기준으로 데이터를 분리하여 
	저장할 배열을 만들고 분리된 데이터를 순서에 맞게 입력하고 출력 
	indexOf()
	substring() 
	사용
	
	
extra ]
	영문 문자열을 입력받아서
	해당 알파벳이 출현하는 빈도를 저장하고
	빈도를 * 로 표현하세요.
	
	  		
	